from typing import Tuple

from matplotlib import pyplot as plt

import isaacgym
from functools import partial

import einops
import numpy as np
import torch

from mpd.parametric_trajectory.trajectory_base import ParametricTrajectoryBase
from mpd.parametric_trajectory.phase_time import PhaseTimeLinear, PhaseTimeSigmoid
from torch_robotics.torch_utils.torch_utils import DEFAULT_TENSOR_ARGS
from torch_robotics.trajectory.utils import finite_difference_vector, interpolate_points_v1
from torch_robotics.visualizers.plot_utils import create_fig_and_axes

from torch.func import vmap, jacrev, functional_call


def get_fd_velocity_matrix_with_boundaries(num_T_pts, ds, tensor_args):
    vel_fd_matrix = torch.zeros((num_T_pts, num_T_pts), **tensor_args)

    # Forward difference for the first point (i=0)
    vel_fd_matrix[0, 0] = -3.0
    vel_fd_matrix[0, 1] = 4.0
    vel_fd_matrix[0, 2] = -1.0
    vel_fd_matrix[0, :] /= 2 * ds

    # Central difference for interior points (1 to num_T_pts - 2)
    for i in range(1, num_T_pts - 1):
        vel_fd_matrix[i, i - 1] = -1.0
        vel_fd_matrix[i, i + 1] = 1.0
        vel_fd_matrix[
            i,
            i,
        ] = 0.0  # Explicitly set the diagonal to zero for clarity
        vel_fd_matrix[i, :] /= 2 * ds

    # Backward difference for the last point (i=num_T_pts - 1)
    vel_fd_matrix[num_T_pts - 1, num_T_pts - 3] = 1.0
    vel_fd_matrix[num_T_pts - 1, num_T_pts - 2] = -4.0
    vel_fd_matrix[num_T_pts - 1, num_T_pts - 1] = 3.0
    vel_fd_matrix[num_T_pts - 1, :] /= 2 * ds

    return vel_fd_matrix


def get_fd_acceleration_matrix_with_boundaries(num_T_pts, ds, tensor_args):
    acc_fd_matrix = torch.zeros((num_T_pts, num_T_pts), **tensor_args)

    # Forward difference for the first point (i=0)
    acc_fd_matrix[0, 0] = 2.0
    acc_fd_matrix[0, 1] = -5.0
    acc_fd_matrix[0, 2] = 4.0
    acc_fd_matrix[0, 3] = -1.0
    acc_fd_matrix[0, :] /= ds**2

    # Central difference for interior points (1 to num_T_pts - 2)
    for i in range(1, num_T_pts - 1):
        acc_fd_matrix[i, i - 1] = 1.0
        acc_fd_matrix[i, i] = -2.0
        acc_fd_matrix[i, i + 1] = 1.0
        acc_fd_matrix[i, :] /= ds**2

    # Backward difference for the last point (i=num_T_pts - 1)
    acc_fd_matrix[num_T_pts - 1, num_T_pts - 4] = -1.0
    acc_fd_matrix[num_T_pts - 1, num_T_pts - 3] = 4.0
    acc_fd_matrix[num_T_pts - 1, num_T_pts - 2] = -5.0
    acc_fd_matrix[num_T_pts - 1, num_T_pts - 1] = 2.0
    acc_fd_matrix[num_T_pts - 1, :] /= ds**2

    return acc_fd_matrix


def create_linear_interpolation_matrix(N: int, H: int, dtype=torch.float32, device="cpu", **kwargs) -> torch.Tensor:
    """
    Creates an interpolation matrix A such that for batched control points x (B x N x D),
    the interpolated trajectory y (B x H x D) is given by y = A @ x.

    - x are N control points (N x D dimensions per batch item).
    - y are H trajectory points (H x D dimensions per batch item).
    - H > N.
    - The trajectory y is generated by linear interpolation and passes through x.

    Args:
        N (int): The number of control points.
        H (int): The desired number of trajectory points.
        dtype (torch.dtype): The data type for the output matrix A.
        device (str or torch.device): The device (e.g., 'cpu' or 'cuda') for the output matrix A.

    Returns:
        torch.Tensor: The H x N interpolation matrix A.

    Raises:
        ValueError: If N or H are not positive integers, or if H is not strictly greater than N.
    """
    if N <= 0 or H <= 0:
        raise ValueError("N and H must be positive integers.")
    if H <= N:
        raise ValueError("H must be strictly greater than N for interpolation to generate more points.")

    # Initialize the H x N interpolation matrix with zeros on the specified device and dtype.
    A = torch.zeros((H, N), dtype=dtype, device=device)

    # Handle the special case where N=1.
    # If there's only one control point, the trajectory is just that point repeated H times.
    if N == 1:
        A[:, 0] = 1.0
        return A

    # Calculate the "time" step for the trajectory points.
    # We consider the N control points to be at normalized "times" 0, 1, ..., N-1.
    # The H trajectory points will be evenly distributed across this same "time" range.
    time_step_y = (N - 1) / (H - 1)

    # Iterate through each desired trajectory point (row in A)
    for j in range(H):
        # Calculate the normalized "time" for the j-th trajectory point.
        t_y_j = j * time_step_y

        # Determine the index of the lower control point (k) that t_y_j is after or at.
        # torch.floor is equivalent to np.floor for this integer conversion.
        k = int(torch.floor(torch.tensor(t_y_j, dtype=dtype, device=device)).item())

        # Handle the edge case for the last point:
        # If t_y_j is exactly N-1 (the end of the range), it should correspond to the last control point x_{N-1}.
        # Using a small epsilon for floating point comparison to ensure robustness.
        if k >= N - 1 or torch.isclose(
            torch.tensor(t_y_j, dtype=dtype, device=device), torch.tensor(float(N - 1), dtype=dtype, device=device)
        ):
            A[j, N - 1] = 1.0
        else:
            # Calculate the fractional part (alpha).
            # Alpha represents how far t_y_j is between x_k and x_{k+1} (from 0 to 1).
            alpha = t_y_j - k

            # Assign weights to the current control point (x_k) and the next control point (x_{k+1}).
            # The sum of weights (1 - alpha + alpha) is always 1, ensuring a linear combination.
            A[j, k] = 1.0 - alpha
            A[j, k + 1] = alpha

    return A


class ParametricTrajectoryWaypoints(ParametricTrajectoryBase):
    # Planner that holds a waypoint position trajectory
    # Velocities, accelerations are computed with finite differencing.
    # It assumes zero velocities and accelerations at the start and goal.

    def __init__(
        self,
        n_control_points=24,
        remove_outer_control_points=False,
        keep_last_control_point=False,
        num_T_pts=128,
        trajectory_duration=5.0,
        phase_time_class="PhaseTimeLinear",
        phase_time_args={},
        use_interpolation_matrix=True,
        tensor_args=DEFAULT_TENSOR_ARGS,
        **kwargs,
    ):
        super().__init__(
            num_T_pts=num_T_pts,
            trajectory_duration=trajectory_duration,
            phase_time_class=phase_time_class,
            phase_time_args=phase_time_args,
            tensor_args=tensor_args,
        )

        self.n_control_points = n_control_points
        self.remove_outer_control_points = remove_outer_control_points
        self.keep_last_control_points = keep_last_control_point

        self.use_interpolation_matrix = use_interpolation_matrix

        self.interpolation_matrix = create_linear_interpolation_matrix(n_control_points, num_T_pts, **tensor_args)

        # finite difference velocity matrix
        self.vel_fd_matrix = get_fd_velocity_matrix_with_boundaries(num_T_pts, self.phase_time.ds, tensor_args)

        # finite difference acceleration matrix
        self.acc_fd_matrix = get_fd_acceleration_matrix_with_boundaries(num_T_pts, self.phase_time.ds, tensor_args)

    def remove_control_points_fn(self, control_points):
        # Remove the first and last waypoints in position
        # keep the last waypoint if we condition on the ee pose goal
        last_control_point = control_points[..., -1, :].clone()
        if self.remove_outer_control_points:
            control_points = control_points[..., 1:-1, :]
            if self.keep_last_control_points:
                control_points = torch.cat((control_points, last_control_point[..., None, :]), dim=-2)
        return control_points

    def augment_control_points_fn(self, control_points, q_pos_start, q_pos_goal):
        q_pos_start, q_pos_goal = self.get_q_pos_start_q_goal(q_pos_start, q_pos_goal)

        if control_points.ndim - q_pos_start.ndim == 1:
            q_pos_start = einops.rearrange(q_pos_start, "... d -> ... 1 d")
            q_pos_goal = einops.rearrange(q_pos_goal, "... d -> ... 1 d")
        else:
            repeat_shape = control_points.shape[:-2]
            if len(repeat_shape) == 1:
                q_pos_start = einops.repeat(q_pos_start, "... -> n 1 ...", n=repeat_shape[0])
                q_pos_goal = einops.repeat(q_pos_goal, "... -> n 1 ...", n=repeat_shape[0])
            elif len(repeat_shape) == 2:
                q_pos_start = einops.repeat(q_pos_start, "... -> n m 1 ...", n=repeat_shape[0], m=repeat_shape[1])
                q_pos_goal = einops.repeat(q_pos_goal, "... -> n m 1 ...", n=repeat_shape[0], m=repeat_shape[1])

        last_inner_control_point = control_points[..., -1, :].clone()[..., None, :]
        if self.keep_last_control_points:
            control_points = control_points[..., :-1, :]
        control_points_augmented = control_points.clone()
        if self.remove_outer_control_points:
            # add control points in between the initial and goal states
            if self.keep_last_control_points:
                control_points_augmented = torch.cat(
                    [q_pos_start, control_points_augmented, last_inner_control_point], dim=-2
                )
            else:
                control_points_augmented = torch.cat([q_pos_start, control_points_augmented, q_pos_goal], dim=-2)

        return control_points_augmented

    def preprocess_control_points(self, q_control_points):
        return q_control_points

    def get_q_trajectory_in_phase(self, q_control_points: torch.Tensor, get_type: Tuple = ("pos", "vel", "acc")):
        # Waypoint interpolation
        q_in_phase_d = {}
        # linear interpolation such that the trajectory has num_T_pts points
        if self.use_interpolation_matrix:
            q_pos_traj = self.interpolation_matrix @ q_control_points
        else:
            q_pos_traj = interpolate_points_v1(q_control_points, self.num_T_pts)
        if "pos" in get_type:
            q_in_phase_d["pos"] = q_pos_traj
        if "vel" in get_type:
            q_in_phase_d["vel"] = self.vel_fd_matrix @ q_pos_traj
        if "acc" in get_type:
            q_in_phase_d["acc"] = self.acc_fd_matrix @ q_pos_traj

        return q_in_phase_d

    def get_grad_q_traj_in_phase_wrt_control_points(
        self,
        control_points: torch.Tensor,
        get_type: Tuple = ("pos", "vel", "acc"),
        remove_control_points: bool = False,
        **kwargs,
    ):
        grad_d = {}

        if self.use_interpolation_matrix:
            for t in get_type:
                if t == "pos":
                    M = self.interpolation_matrix
                elif t == "vel":
                    M = self.vel_fd_matrix @ self.interpolation_matrix
                elif t == "acc":
                    M = self.acc_fd_matrix @ self.interpolation_matrix
                if remove_control_points:
                    # If the outer control points are fixed, we can remove them to compute gradients only
                    # wrt the inner control points
                    M = self.remove_control_points_fn(M.unsqueeze(-1)).squeeze(-1)
                grad_d[t] = M.unsqueeze(0)  # add batch dimension
        else:
            # compute the trajectory Jacobian wrt to the control points
            grad_q_wrt_cp_d = vmap(
                jacrev(partial(self.get_q_trajectory_in_phase, get_type=get_type), argnums=0), in_dims=0
            )(control_points.unsqueeze(-3))

            grad_d = {}
            for t in get_type:
                # remove dummy dimensions
                g = einops.rearrange(grad_q_wrt_cp_d[t], "... 1 h d1 1 n d2 -> ... h d1 n d2")
                grad_d[t] = g

        return grad_d


if __name__ == "__main__":

    n_control_points = 6
    control_points_x = np.linspace(-1, 1, n_control_points, dtype=np.float32)
    control_points_y = control_points_x + 0.2 * np.sin(control_points_x * 10.0)
    control_points = np.stack((control_points_x, control_points_y), axis=1)

    num_T_pts = 30
    trajectory_duration = 5.0

    fig_cps, axs_cps = create_fig_and_axes(2, figsize=(8, 6))
    fig_qs, axs_qs = plt.subplots(control_points.shape[-1], 3, figsize=(12, 8))
    fig_phase, axs_phase = create_fig_and_axes(2, figsize=(8, 6))
    fig_rs, axs_rs = create_fig_and_axes(2, figsize=(8, 6))
    for l, (phase_class, phase_time_args, line_color, line_style) in enumerate(
        zip(["PhaseTimeLinear", "PhaseTimeSigmoid"], [{}, {"k": 8}], ["gray", "orange"], ["solid", "solid"])
    ):
        print(f"Phase class: {phase_class}")

        parametric_traj = ParametricTrajectoryWaypoints(
            n_control_points=n_control_points,
            degree=5,
            num_T_pts=num_T_pts,
            zero_vel_at_start_and_goal=True,
            zero_acc_at_start_and_goal=True,
            trajectory_duration=trajectory_duration,
            phase_time_class=phase_class,
            phase_time_args=phase_time_args,
            tensor_args=dict(device="cpu", dtype=torch.float32),
        )

        control_points_th = torch.from_numpy(control_points)[None, ...]
        q_start = control_points_th[0, 0, ...]
        q_goal = control_points_th[0, -1, ...]

        q_traj_d = parametric_traj.get_q_trajectory(
            control_points_th, q_start, q_goal, get_type=("pos", "vel", "acc"), get_time_representation=True
        )

        q = q_traj_d["pos"][0].detach()
        dq = q_traj_d["vel"][0].detach()
        ddq = q_traj_d["acc"][0].detach()

        # plot control points and q_pos
        axs_cps.scatter(control_points_x, control_points_y, c="blue", marker="o", s=10**2, zorder=100)
        axs_cps.plot(q[:, 0], q[:, 1], color=line_color, linestyle=line_style, linewidth=3, marker="x")

        # plot q, dq, ddq in time
        t = parametric_traj.phase_time.t

        # integrate q and dq for checking correctness
        print(f"q(T) (from Waypoints): {q[-1]}")
        q_T_from_dq = (
            q[0] + torch.cumsum(dq * torch.diff(torch.cat([torch.zeros([1]), t]), dim=-1)[..., None], dim=0)[-1]
        )
        print(f"q(T) (from dq integration): {q_T_from_dq}")

        print(f"dq(T) (from Waypoints): {dq[-1]}")
        dq_T_from_ddq = (
            dq[0] + torch.cumsum(ddq * torch.diff(torch.cat([torch.zeros([1]), t]), dim=-1)[..., None], dim=0)[-1]
        )
        print(f"dq(T) (from ddq integration): {dq_T_from_ddq}\n")

        for i, x in enumerate([q, dq, ddq]):
            for j in range(x.shape[1]):
                axs_qs[j, i].plot(t.detach().cpu(), x[:, j], linestyle=line_style, color=line_color, linewidth=4)
                axs_qs[j, i].set_yticks([x[:, j].min(), x[:, j].max()])
                axs_qs[j, i].set_yticklabels([f"${x[:, j].min():.2f}$", f"${x[:, j].max():.2f}$"])

        if phase_class == "PhaseTimeLinear":
            phase_time_class_fn = PhaseTimeLinear
        elif phase_class == "PhaseTimeSigmoid":
            phase_time_class_fn = partial(PhaseTimeSigmoid, **phase_time_args)
        else:
            raise NotImplementedError

        # plot the phase variable in time
        phase = phase_time_class_fn(trajectory_duration=trajectory_duration, num_T_pts=num_T_pts)
        t_np = phase.t.cpu().detach().numpy()
        axs_phase.plot(t_np, phase.s.cpu().detach(), color=line_color, linestyle="solid", linewidth=4, label="s")
        axs_phase.plot(t_np, phase.rs.cpu().detach(), color=line_color, linestyle="dashed", linewidth=4, label="ds/dt")
        axs_phase.plot(
            t_np, phase.dr_ds.cpu().detach(), color=line_color, linestyle="dotted", linewidth=4, label="d^2s/dt^2"
        )
        axs_phase.set_xlabel("t")
        axs_phase.legend()

        # plot ds_dt in phase
        s_np = phase.s.cpu().detach().numpy()
        axs_rs.plot(s_np, phase.rs.cpu().detach(), color=line_color, linestyle="dashed", linewidth=4, label="ds/dt")
        axs_rs.plot(
            s_np, phase.dr_ds.cpu().detach(), color=line_color, linestyle="dotted", linewidth=4, label="d^2s/dt^2"
        )
        axs_rs.set_xlabel("s")
        axs_rs.legend()

    plt.show()
